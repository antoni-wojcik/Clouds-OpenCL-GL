//#pragma OPENCL EXTENSION cl_khr_3d_image_writes : enable

const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_REPEAT | CLK_FILTER_NEAREST;

void kernel generate(__read_only image3d_t vertices, __read_only image3d_t image_in, __write_only image3d_t image_out, const float blending, const float persistence) {

    int x = get_global_id(0);
    int y = get_global_id(1);
    int z = get_global_id(2);
    
    int texture_size = get_image_width(image_in);
    int nodes = get_image_width(vertices);
    
    int grid_size = texture_size/(nodes-2);
    int3 node_loc = (int3)(x/grid_size+1, y/grid_size+1, z/grid_size+1);
    
    float min_dist = 3*grid_size*grid_size;
    
    for(int a = -1; a < 2; a++) for(int b = -1; b < 2; b++) for(int c = -1; c < 2; c++){
        int4 loc = (int4)(node_loc.x+a, node_loc.y+b, node_loc.z+c, 1);
        uint3 vertex_pixel = read_imageui(vertices, sampler, loc).xyz;
        float3 pixel = (float3)(vertex_pixel.x, vertex_pixel.y, vertex_pixel.z);
        pixel.x += grid_size*(loc.x-1);
        pixel.y += grid_size*(loc.y-1);
        pixel.z += grid_size*(loc.z-1);
        float dist = ((float)(x)-pixel.x)*((float)(x)-pixel.x) + ((float)(y)-pixel.y)*((float)(y)-pixel.y) + ((float)(z)-pixel.z)*((float)(z)-pixel.z);
        if(dist < min_dist) min_dist = dist;
    }
    
    float brightness;
    
    float tuning = 1.0f-tanh((float)(min_dist/(float)(3*grid_size*grid_size)*persistence));
    
    if(blending == 1.0f) brightness = tuning;
    else brightness = blending * tuning + (1.0f-blending) * read_imagef(image_in, sampler, (int4)(x, y, z, 1)).x;
        
    write_imagef(image_out, (int4)(x, y, z, 1), (float4)(brightness, 0.0f, 0.0f, 1.0f));
}
